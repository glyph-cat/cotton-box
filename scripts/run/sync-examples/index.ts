import { grey, red } from 'chalk'
import {
  existsSync,
  mkdirSync,
  readFileSync,
  readdirSync,
  statSync,
  writeFileSync,
} from 'fs'
import { ENCODING_UTF_8 } from '../../constants'

function crawl(
  directoryPath: string,
  callback: (pathSegments: Array<string>, fileName: string) => void,
  previousPaths: Array<string> = []
): void {
  const directoryItems = readdirSync(
    `${directoryPath}/${previousPaths.join('/')}`,
    ENCODING_UTF_8
  )
  for (const item of directoryItems) {
    const nextPathSegments: Array<string> = [...previousPaths, item]
    if (statSync(`${directoryPath}/${nextPathSegments.join('/')}`).isDirectory()) {
      crawl(directoryPath, callback, nextPathSegments)
    } else {
      if (/\.draft\./gi.test(item)) {
        console.log(grey(`Skipping draft file "${previousPaths.join('/')}/${item}"...`))
        continue
      }
      if (/\.(css|tsx?)$/i.test(item)) {
        callback(previousPaths, item)
      } else if (/\.jsx?$/i.test(item)) {
        console.log(red(`JS file not allowed: ${previousPaths.join('/')}/${item}`))
        console.log(red('Please use either TS or TSX only'))
        process.exit(1)
      } else {
        console.log(grey(`Skipping irrelevant file "${previousPaths.join('/')}/${item}"...`))
      }
    }
  }
}

function deepSet(
  object: Record<string, unknown>,
  pathSegments: Array<string>,
  value: unknown
): void {
  if (pathSegments.length <= 0) { return } // Early exit
  let pointer: unknown = object
  for (let i = 0; i < (pathSegments.length - 1); i++) {
    const pathSegment = pathSegments[i]
    if (!Object.prototype.hasOwnProperty.call(pointer, pathSegment)) {
      pointer[pathSegment] = {}
    }
    pointer = pointer[pathSegment]
  }
  pointer[pathSegments[pathSegments.length - 1]] = value
}

const pathSpecs: Array<[pathSegments: Array<string>, fileName: string]> = []
const pathToCrawl = './packages/examples-web/src/pages/examples'
const destinationFrontPath = './packages/docs/src/examples'
const destinationFrontPathSegments = destinationFrontPath.split('/')
crawl(pathToCrawl, (pathSegments, fileName) => {
  if (/\.tsx?$/i.test(fileName)) {
    pathSpecs.push([pathSegments, fileName])
  }
  const destination = `${pathSegments.join('/')}/${fileName}`
  let fileContents = readFileSync(`${pathToCrawl}/${destination}`, ENCODING_UTF_8)
  if (/#\s*region\s+example/i.test(fileContents)) {
    const fileLines = fileContents.split('\n')
    const lineAfterLastImport = findLineAfterLastImport(fileLines)
    const importLines = fileLines.slice(0, lineAfterLastImport)
    const bodyStartLine = findLineAfterMatchedPattern(fileLines, /#\s*region\s+example/i)
    const bodyEndLine = findLineAfterMatchedPattern(fileLines, /#\s*endregion\s+example/i) - 1
    const bodyLines = fileLines.slice(bodyStartLine, bodyEndLine)
    const indentationWidth = (fileLines[bodyStartLine - 1].match(/^\s+/) ?? []).join('').length
    for (let i = 0; i < bodyLines.length; i++) {
      bodyLines[i] = bodyLines[i].substring(indentationWidth, bodyLines[i].length)
    }
    fileContents = importLines.join('\n') + '\n\n' + bodyLines.join('\n') + '\n'
  }
  prepDir([...destinationFrontPathSegments, ...pathSegments])
  writeFileSync(`${destinationFrontPath}/${destination}`, fileContents, ENCODING_UTF_8)
})

// Sort by longest path first, else sub-property will be assigned as string for
// shorter paths and when deeper property needs to be assigned, it becomes a problem.
pathSpecs.sort((a, b) => {
  if (a[0].length !== b[0].length) {
    return a[0].length > b[0].length ? -1 : 1
  } else {
    return 0
  }
})

const obj: Record<string, unknown> = {}
for (const [pathSegments, fileName] of pathSpecs) {
  if (pathSegments.length <= 0) { continue }
  deepSet(obj, [...pathSegments, fileName], 0)
}

// console.log(JSON.stringify(obj, null, 2))
writeFileSync(
  './packages/examples-web/src/constants/page-index.scripted.ts',
  [
    '// Do not edit - this file is automatically generated',
    `export const PageIndex=${JSON.stringify(obj)}`,
    '',
  ].join('\n'),
  ENCODING_UTF_8
)

function prepDir(pathSegments: Array<string>): void {
  let pathPointer = ''
  for (let i = 0; i < pathSegments.length; i++) {
    pathPointer += `${pathSegments[i]}/`
    if (!existsSync(pathPointer)) {
      mkdirSync(pathPointer)
    }
  }
}

function findLineAfterLastImport(lines: Array<string>): number {
  // This assumes that import statements starts at first line
  for (let i = 0; i < lines.length; i++) {
    if (!/^import/i.test(lines[i])) {
      return i
    }
  }
  return lines.length - 1
}

function findLineAfterMatchedPattern(lines: Array<string>, pattern: RegExp): number {
  for (let i = 0; i < lines.length; i++) {
    if (pattern.test(lines[i])) {
      return i + 1
    }
  }
  return lines.length - 1
}
