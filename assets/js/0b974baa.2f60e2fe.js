"use strict";(self.webpackChunkcotton_box_docs=self.webpackChunkcotton_box_docs||[]).push([[7545],{4708:(e,t,n)=>{n.d(t,{IG:()=>w,P3:()=>j});var o=n(39665),a=n(59047),i=n(8532),s=n(68553),r=n(63639),l=n(96540),c=n(74848);const d="index.js",h="App.tsx",u="styles.css",p="index.module.css",m=!1,f={[d]:["import { createRoot } from 'react-dom/client'","import App from './App.tsx'",`import './${u}'`,"","const root = createRoot(document.getElementById('root'))","root.render(<App />)",""].join("\n"),[u]:["body {","  font-family: sans-serif;","  -webkit-font-smoothing: auto;","  -moz-font-smoothing: auto;","  -moz-osx-font-smoothing: grayscale;","  font-smoothing: auto;","  text-rendering: optimizeLegibility;","  font-smooth: always;","  -webkit-tap-highlight-color: transparent;","  -webkit-touch-callout: none;","}"].join("\n"),"package.json":["{",`  "main": "${d}",`,'  "dependencies": {','    "react": "^18.0.0",','    "react-dom": "^18.0.0",','    "react-scripts": "^5.0.0"',"  }","}"].join("\n"),"public/index.html":["<!DOCTYPE html>",'<html lang="en">',"  <head>",'    <meta charset="UTF-8">','    <meta name="viewport" content="width=device-width, initial-scale=1.0">',"    <title>Example</title>","  </head>","  <body>",'    <div id="root"></div>',"  </body>","</html>"].join("\n")};function g(){const{colorMode:e}=(0,i.G)();return"light"===e?a.Zw:a.$o}const x={customSetup:{dependencies:{"cotton-box":"latest","cotton-box-react":"latest"}},options:{editorWidthPercentage:65,editorHeight:"45vh",showLineNumbers:!0,showRefreshButton:!0,showTabs:!1,wrapContent:!0}};function w(e){return(0,r.i)()?(0,c.jsx)(b,{...e}):null}function b(e){let{code:t,css:n,extraDependencies:a,options:i}=e;const s=g();return(0,c.jsx)(c.Fragment,{children:m?(0,c.jsx)(o.l5,{files:{...f,[h]:t,...n?{[p]:n}:{}},...x,theme:s,customSetup:{...x.customSetup,entry:d,dependencies:{...x.customSetup.dependencies,...a}},options:{...x.options,activeFile:h,showConsole:/console\./.test(t),...i},children:(0,c.jsxs)(o.am,{children:[(0,c.jsx)(S,{}),(0,c.jsx)(o.G5,{})]})}):(0,c.jsx)(o.OZ,{files:{...f,[h]:t,...n?{[p]:n}:{}},...x,theme:s,customSetup:{...x.customSetup,entry:d,dependencies:{...x.customSetup.dependencies,...a}},options:{...x.options,activeFile:h,showConsole:/console\./.test(t),...i}})})}function j(e){return(0,r.i)()?(0,c.jsx)(v,{...e}):null}function v(e){let{code:t}=e;const n=g();return(0,c.jsx)(c.Fragment,{children:m?(0,c.jsx)(o.l5,{files:{[d]:t},...x,theme:n,customSetup:{...x.customSetup,entry:d},options:{...x.options,activeFile:d},children:(0,c.jsxs)(o.am,{children:[(0,c.jsx)(S,{}),(0,c.jsx)(o.X2,{})]})}):(0,c.jsx)(o.OZ,{files:{[d]:t},...x,theme:n,customSetup:{...x.customSetup,entry:d},options:{...x.options,activeFile:d,layout:"console"}})})}function S(){const{code:e,updateCode:t}=(0,o.Pe)(),{sandpack:n}=(0,o.ny)();return(0,c.jsx)(o.aN,{children:(0,c.jsx)("div",{style:{flex:1},children:(0,c.jsx)(s.Ay,{language:"typescript",theme:"vs-dark",defaultValue:e,onChange:(0,l.useCallback)((e=>t(e||"")),[t]),options:{fontSize:14,minimap:{enabled:!1},scrollBeyondLastLine:!1,wordWrap:"on"}},n.activeFile)})})}},84911:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>u,default:()=>g,frontMatter:()=>h,metadata:()=>o,toc:()=>m});const o=JSON.parse('{"id":"learn/tutorial/waiting-for-state-change","title":"Waiting For State Change","description":"Waiting is an observation strategy that utilizes .watch under the hood. It allows us to watch for state value changes until it matches a certain value or fulfils a certain condition then stops watching and returns a snapshot of that state.","source":"@site/docs/learn/tutorial/waiting-for-state-change.mdx","sourceDirName":"learn/tutorial","slug":"/learn/tutorial/waiting-for-state-change","permalink":"/cotton-box/docs/learn/tutorial/waiting-for-state-change","draft":false,"unlisted":false,"editUrl":"https://github.com/glyph-cat/cotton-box/tree/main/packages/docs/docs/learn/tutorial/waiting-for-state-change.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"learnSidebar","previous":{"title":"Watching For State Changes","permalink":"/cotton-box/docs/learn/tutorial/watching-for-state-changes"},"next":{"title":"Disposal","permalink":"/cotton-box/docs/learn/tutorial/disposal"}}');var a=n(74848),i=n(28453);const s="import { StateManager } from 'cotton-box'\n\nif (typeof window !== 'undefined') {\n  // #region example\n  (async function () {\n    let intervalCount = 0\n    const CounterState = new StateManager(0)\n    const intervalRef = setInterval(() => {\n      // Generate random number between 1 to 100\n      const randomNumber = 1 + Math.floor(Math.random() * 100)\n      console.log(`randomNumber: ${randomNumber}`)\n      CounterState.set(randomNumber)\n      intervalCount++\n    }, 1000)\n    const awaitedValue = await CounterState.wait((state) => {\n      return state % 5 === 0\n    })\n    clearInterval(intervalRef)\n    console.log(`Received a number divisible by 5 after ${intervalCount} attempts.`)\n    console.log(`The number is ${awaitedValue}`)\n  })()\n  // #endregion example\n}\n\nexport { default } from '~components/none'\n",r="import { StateManager } from 'cotton-box'\n\nif (typeof window !== 'undefined') {\n  // #region example\n  (async function () {\n    let intervalCount = 0\n    const CounterState = new StateManager(0)\n    const intervalRef = setInterval(() => {\n      // Generate random number between 40 to 50\n      const randomNumber = 40 + Math.round(Math.random() * 10)\n      console.log(`randomNumber: ${randomNumber}`)\n      CounterState.set(randomNumber)\n      intervalCount++\n    }, 1000)\n    await CounterState.wait(42)\n    clearInterval(intervalRef)\n    console.log(`Promise resolved after ${intervalCount} attempts`)\n  })()\n  // #endregion example\n}\n\nexport { default } from '~components/none'\n";var l=n(57869),c=n(4708),d=n(7888);const h={sidebar_position:4},u="Waiting For State Change",p={},m=[{value:"Waiting for a specific value",id:"waiting-for-a-specific-value",level:2},{value:"Waiting for a condition to be fulfilled",id:"waiting-for-a-condition-to-be-fulfilled",level:2}];function f(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"waiting-for-state-change",children:"Waiting For State Change"})}),"\n",(0,a.jsxs)(t.p,{children:["Waiting is an observation strategy that utilizes ",(0,a.jsx)(t.code,{children:".watch"})," under the hood. It allows us to watch for state value changes until it matches a certain value or fulfils a certain condition then stops watching and returns a snapshot of that state."]}),"\n",(0,a.jsx)(t.p,{children:"Consider the code below, there are two things that we can do with it."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"const CounterState = new StateManager(0)\n\nsetInterval(() => {\n  const randomNumber = Math.round(Math.random() * 100)\n  CounterState.set(randomNumber)\n}, 1000)\n"})}),"\n",(0,a.jsx)(t.h2,{id:"waiting-for-a-specific-value",children:"Waiting for a specific value"}),"\n",(0,a.jsxs)(t.p,{children:["We can pass a value to ",(0,a.jsx)(t.code,{children:".wait"})," and it will resolve when the state matches that value. The state is compared with the expected value using ",(0,a.jsx)(l.L,{href:d.k.API_REFERENCE_URL_OBJECT_IS,children:"Object.is"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["In this example, the promise will resolve when the state equals to ",(0,a.jsx)(t.code,{children:"42"}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"await CounterState.wait(42)\n"})}),"\n",(0,a.jsx)(c.P3,{code:r}),"\n",(0,a.jsx)("br",{}),"\n",(0,a.jsx)(t.admonition,{type:"tip",children:(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:".isInitializing"})," property of ",(0,a.jsx)(l.L,{href:`${d.k.DOCS_API_CORE_URL}/StateManager`,children:"StateManager"})," and ",(0,a.jsx)(l.L,{href:`${d.k.DOCS_API_CORE_URL}/AsyncStateManager`,children:"AsyncStateManager"})," can be used in a similar way to wait for initialization to complete (Example: ",(0,a.jsx)(t.code,{children:"ExampleState.isInitializing.wait(false)"}),")."]})}),"\n",(0,a.jsx)(t.h2,{id:"waiting-for-a-condition-to-be-fulfilled",children:"Waiting for a condition to be fulfilled"}),"\n",(0,a.jsxs)(t.p,{children:["We can also pass a callback to ",(0,a.jsx)(t.code,{children:".wait"})," to fine tune the waiting behavior. The state snapshot will be passed to the function each time the state changes and the callback should return either ",(0,a.jsx)(t.code,{children:"true"})," or ",(0,a.jsx)(t.code,{children:"false"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"In this example, the promise will resolve when the state is a number that is divisible by 5."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"await CounterState.wait(state => state % 5 === 0)\n"})}),"\n",(0,a.jsx)(c.P3,{code:s}),"\n",(0,a.jsx)("br",{}),"\n",(0,a.jsx)(t.admonition,{type:"tip",children:(0,a.jsxs)(t.p,{children:["When the condition is fulfilled, the ",(0,a.jsx)(t.code,{children:".wait"})," method returns a Promise that resolves into a snapshot of the state that fulfilled the condition. This is useful when we only know what condition to expect but not a specific value, as we could capture the value right after waiting."]})})]})}function g(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(f,{...e})}):f(e)}}}]);