"use strict";(self.webpackChunkcotton_box_docs=self.webpackChunkcotton_box_docs||[]).push([[1892],{4373:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>c,toc:()=>h});var i=n(4848),s=n(8453),a=n(6280),r=n(3439);const o={sidebar_position:6},l="Persisting State",c={id:"learn/tutorial/persisting-state",title:"Persisting State",description:"StateManager and AsyncStateManager provides three lifecycle hooks:",source:"@site/docs/learn/tutorial/persisting-state.mdx",sourceDirName:"learn/tutorial",slug:"/learn/tutorial/persisting-state",permalink:"/cotton-box/docs/learn/tutorial/persisting-state",draft:!1,unlisted:!1,editUrl:"https://github.com/glyph-cat/cotton-box/tree/main/packages/docs/docs/learn/tutorial/persisting-state.mdx",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"learnSidebar",previous:{title:"Disposal",permalink:"/cotton-box/docs/learn/tutorial/disposal"},next:{title:"Which State Manager Should I Use?",permalink:"/cotton-box/docs/learn/tutorial/which-state-manager-should-i-use"}},d={},h=[{value:"Persisting &amp; resetting state",id:"persisting--resetting-state",level:2},{value:"Retrieving state",id:"retrieving-state",level:2},{value:"Putting everything together",id:"putting-everything-together",level:2}];function g(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"persisting-state",children:"Persisting State"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"/cotton-box/docs/api/core/StateManager",children:(0,i.jsx)(t.code,{children:"StateManager"})})," and ",(0,i.jsx)(t.a,{href:"/cotton-box/docs/api/core/AsyncStateManager",children:(0,i.jsx)(t.code,{children:"AsyncStateManager"})})," provides three lifecycle hooks:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"init"})," \u2014 triggers when the State Manager is instantiated"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"didSet"})," \u2014 triggers each time the state is changed with ",(0,i.jsx)(t.code,{children:".set"}),", even if the value remains the same"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"didReset"})," \u2014 triggers each time ",(0,i.jsx)(t.code,{children:".reset"})," is called"]}),"\n"]}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsx)(t.p,{children:"These lifecycle hooks are are independent of each other and completely optional, but as far as lifecycle management is concerned, it is generally recommended to use all three."})}),"\n",(0,i.jsx)(t.h2,{id:"persisting--resetting-state",children:"Persisting & resetting state"}),"\n",(0,i.jsxs)(t.p,{children:["To begin, we can start by defining ",(0,i.jsx)(t.code,{children:"didSet"})," and ",(0,i.jsx)(t.code,{children:"didReset"}),". By doing so, we would have a better idea of how the state is being persisted, which in return makes it easier for us to figure out how to initialize the state. In this example, we will serialize the state using ",(0,i.jsx)(a.L,{href:r.k.API_REFERENCE_URL_JSON_STRINGIFY,children:"JSON.stringify"})," and save it to ",(0,i.jsx)(a.L,{href:r.k.API_REFERENCE_URL_LOCAL_STORAGE,children:"localStorage"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const UserState = new StateManager({\n    firstName: 'John',\n    lastName: 'Smith',\n    luckyNumber: 42,\n  }, {\n  // highlight-start\n  lifecycle: {\n    didSet({ state, defaultState }) {\n      localStorage.removeItem('key', JSON.stringify(state))\n    },\n    didReset() {\n      localStorage.removeItem('key')\n    },\n  },\n  // highlight-end\n})\n"})}),"\n",(0,i.jsx)(t.admonition,{title:"Caution!",type:"danger",children:(0,i.jsxs)(t.p,{children:["Do not call ",(0,i.jsx)(t.code,{children:".set"})," inside the ",(0,i.jsx)(t.code,{children:"didSet"})," lifecycle hook as this will result in infinite recursion. The same applies to calling ",(0,i.jsx)(t.code,{children:".reset"})," in the ",(0,i.jsx)(t.code,{children:"didReset"})," lifecycle hook and calling ",(0,i.jsx)(t.code,{children:".init"})," in the ",(0,i.jsx)(t.code,{children:"init"})," lifecycle hook."]})}),"\n",(0,i.jsx)(t.h2,{id:"retrieving-state",children:"Retrieving state"}),"\n",(0,i.jsxs)(t.p,{children:["Now that we know how the state is being persisted, all we need to do is to parse it back with ",(0,i.jsx)(a.L,{href:r.k.API_REFERENCE_URL_JSON_PARSE,children:"JSON.parse"})," in the ",(0,i.jsx)(t.code,{children:"init"})," lifecycle hook."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const UserState = new StateManager({\n    firstName: 'John',\n    lastName: 'Smith',\n    luckyNumber: 42,\n  }, {\n  lifecycle: {\n    // highlight-start\n    init({ commit }) {\n      const persistedState = JSON.parse(localStorage.getItem('key'))\n      commit(persistedState)\n    },\n    // highlight-end\n    didSet({ state, defaultState }) {\n      localStorage.removeItem('key', JSON.stringify(state))\n    },\n    didReset() {\n      localStorage.removeItem('key')\n    },\n  },\n})\n"})}),"\n",(0,i.jsx)(t.h2,{id:"putting-everything-together",children:"Putting everything together"}),"\n",(0,i.jsx)(t.p,{children:"The code in the section above is a simple example of we can persist data and use it to initialize a State Manager. In reality, however, it could be a little bit more complicated. The code below shows what it might look like in a more realistic scenario."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const UserState = new StateManager({\n    firstName: 'John',\n    lastName: 'Smith',\n    luckyNumber: 42,\n  }, {\n  // 0. Do not run any lifecycle hooks in server environment\n  //    (for projects that uses server-side rendering)\n  lifecycle: typeof window === 'undefined' ? {} : {\n    init({ commit, commitNoop, defaultState }) {\n      // 1. Get raw (string) state.\n      const rawState = localStorage.getItem('key')\n      if (rawState) {\n        try {\n          // 2. If it exists, attempt to parse it.\n          const persistedState = JSON.parse(rawState)\n          // 3. Commit the state by merging the default and the persisted states\n          //    using the spread operator.\n          commit({\n            ...defaultState,\n            ...persistedState,\n          })\n          // 4. Initialization has completed,\n          //    execution of the function can be ended early.\n          return\n        } catch (error) {\n          // 5. try-catch is used in case of corrupted JSON string.\n          console.error(error)\n        }\n      }\n      commitNoop() // pronounced as \"commit no-op\"\n      // 6. This indicates that initialization has been completed but without\n      //    the need to change the state (state remains to be the default value).\n    },\n    didSet({ state, defaultState }) {\n      localStorage.removeItem('key', JSON.stringify(state))\n    },\n    didReset() {\n      localStorage.removeItem('key')\n    },\n  },\n})\n"})})]})}function m(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(g,{...e})}):g(e)}}}]);